import { RequestHandler } from 'express';
import { ExpressRequestError, ExpressRequestErrorType } from 'issue-maker';
import { Promise as BluePromise } from 'bluebird';
import { generate as generateRandId } from 'shortid';
import { _Users } from '@models/_Users';
import { Users } from '@models/Users';
import { Jwt } from '../../utils/Jwt';

export const signUp: RequestHandler = async (req, res, next) => {
  try {
    if (!req.body._fbLogin && !req.body.identityToken) {
      if (await _Users.findOne({ email: req.body.email }).exec()) {
        return next(new ExpressRequestError(ExpressRequestErrorType.CONFLICT, 'Email already registered'));
      }
    }

    let email = '';
    let _userCond: any = {};

    if (req.body.phone) {
      _userCond = { phone: req.body.phone };
    } else {
      _userCond = { email: req.body.email };
    }

    /* TODO: dont quite understand why these two are not the same  _user & user 
    (maybe the fist one is just for userForm input and the other one is for full users db data)
    the former one seems to find email or phone user
    and the latter one at first sight seems to scan the db for exisiting emails

    Probably wrong about this and both fields are neccessary ðŸ¤·

    Dont understand why the types are :any if we import the @models 
    */
    let _user: any = {};
    let user: any = {};

    if (!req.body.identityToken) {
      email = req.body.email;
      _user = await _Users.findOne(_userCond).exec();
      user = await Users.findOne({ email }).exec();
    } else {
      _user = await _Users.findOne({ identityToken: req.body.identityToken }).exec();

      if (_user) {
        email = _user.email;
        user = await Users.findOne({ email }).exec();
      }
    }

    // Phone number verification
    if (!_user) {
      return next(
        new ExpressRequestError(
          ExpressRequestErrorType.UNPROCESSABLE_ENTITY,
          'User does not have phone number verified!',
        ),
      );
    } else if (_user && !_user.phoneVerified) {
      if (!req.body.phoneVerificationCode) {
        return next(
          new ExpressRequestError(ExpressRequestErrorType.UNPROCESSABLE_ENTITY, 'Verification code required'),
        );
      } else if (req.body.phoneVerificationCode !== _user.phoneVerificationCode) {
        return next(new ExpressRequestError(ExpressRequestErrorType.UNPROCESSABLE_ENTITY, 'Invalid verification code'));
      }
    }

    if (!req.body._fbLogin && !req.body.password && !req.body.identityToken) {
      return next(
        new ExpressRequestError(
          ExpressRequestErrorType.UNPROCESSABLE_ENTITY,
          'Either password or Facebook login is required',
        ),
      );
    }

    if (req.body._fbLogin && req.body.phone) {
      // same email and different phone
      if (_user.email === req.body.email && _user.phone !== req.body.phone) {
        return next(
          new ExpressRequestError(ExpressRequestErrorType.CONFLICT, 'Phone is associated with a different account'),
        );
      }

      let emailsAreDifferent = false;
      if (!_user.email) {
        emailsAreDifferent = false;
      } else {
        emailsAreDifferent = _user.email !== req.body.email;
      }
      // same phone, different email
      if (_user.phone === req.body.phone && emailsAreDifferent) {
        return next(
          new ExpressRequestError(ExpressRequestErrorType.CONFLICT, 'Email is associated with a different account'),
        );
      }
    }

    if (req.body.identityToken && req.body.identityToken === _user.identityToken) {
      if (req.body.phone !== _user.phone) {
        return next(
          new ExpressRequestError(ExpressRequestErrorType.CONFLICT, 'Phone is associated with a different account'),
        );
      }
    }

    // if socialLogin, check socialId
    if (req.body._fbLogin && _user.socialId && req.body.socialId !== _user.socialId) {
      return next(
        new ExpressRequestError(
          ExpressRequestErrorType.UNPROCESSABLE_ENTITY,
          'Invalid login credentials (SIDMSMTCHERR)',
        ),
      );
    }
    /* TODO: would research a possible validation pattern but the if's seems to be structured decent enough */

    // everything ok
    _user.email = email;
    _user.socialId = req.body.socialId;
    _user.role = 'user';
    _user.identityToken = req.body.identityToken;

    if (!req.body._fbLogin && !req.body.identityToken) {
      _user.password = req.body.password || undefined;
    }

    _user.phoneVerified = true;
    _user.phoneVerificationCode = '-over-' + generateRandId();

    let newUser: typeof user = null;

/* TODO: would use regular expression to map/forEach req.body to user for cleaner look (5 if's seems too much)- returns user obj from req.body 
**silly pseudo like example (it shouldn't work):

    Object.keys(user).forEach((userField) => {
      Object.keys(req.body).forEach((key) => {
        if (userField === key) // probably would be good to add && user[key] != undefined
          userField = user[key];
      }
    })
*/
    if (user) {
      if (req.body.firstName) {
        user.firstName = req.body.firstName;
      }
      if (req.body.lastName) {
        user.lastName = req.body.lastName;
      }
      if (req.body.email) {
        user.email = req.body.email;
      }
      if (req.body.phone) {
        user.phone = req.body.phone;
      }
      if (req.body.displayImage) {
        user.displayImage = req.body.displayImage;
      }
      user.deviceToken = req.body.deviceToken || null;

      /**
       * If user exists and is just logging in, don't update it's picture
       * If user will want to change picture, he will do it after logging in.
       */
      // if (!user.displayImage) {
      //   user.displayImage = req.body.displayImage || null;
      // }

      try {
        // await Users.updateOne({ email }, { $set: user });
        await user.save(); // happens in bg
      } catch (e) {
        // tslint:disable-next-line:no-console
        console.log('user save err', e);
      }
    } else {
      // TODO: can use the same regex mentioned above but i wouldnt use it here as it wouldnt
      // be as readable
      newUser = new Users({
        firstName: req.body.firstName,
        lastName: req.body.lastName,
        email: req.body.email,
        phone: req.body.phone,
        role: 'user',
        deviceToken: req.body.deviceToken || null,
        displayImage: req.body.displayImage || null,
      });

      try {
        await newUser.save();
      } catch (e) {
        /* 
        TODO: would disable no-console in tsconfig if this is a continuous comment (if possible)
        or switch to alert managment like Toast 
        */
        // tslint:disable-next-line:no-console
        console.log('new user save err', e);
      }
    }

    const accessTokenPromise = Jwt.sign({
      id: user ? user._id : newUser._id, // TODO: nice to see some simple ternary operation in use
      email,
      role: 'user',
    });

    let accessToken = {};
    try {
      [accessToken] = await BluePromise.all([accessTokenPromise, _user.save()]);
    } catch (e) {
      /* TODO: probably should implement Toast|AlertManagment if response is needed for the client */
      // tslint:disable-next-line:no-console
      console.log('signing error', e);
    }

    req.body.password = undefined;
    req.body._id = user ? user._id : newUser._id;

    return res.status(newUser ? 201 : 200).send({
      status: 'success',
      accessToken,
      userDetails: await Users.findOne({ email }).lean().exec(),
    });
  } catch (err) {
    return next(new ExpressRequestError(ExpressRequestErrorType.INTERNAL_SERVER_ERROR, err));
  }
};
